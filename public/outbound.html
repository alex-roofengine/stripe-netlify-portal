<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoofEngine Outbound Portal</title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
  <div class="container">
    <h1>RoofEngine Outbound Payments</h1>

    <section id="customerSection">
      <h2>Select Client</h2>
      <select id="custSel">
        <option>Loading customers...</option>
      </select>
      <div id="selHelp" class="muted">Fetching clients from Stripe...</div>
    </section>

    <section id="paymentSection">
      <h2>Payment Methods</h2>
      <div id="pmPicker"></div>
      <div id="addNewBtnWrap" style="display:none;">
        <button id="addNewBtn">Add New Payment Method</button>
      </div>
      <div id="newCardWrap" style="display:none;"></div>
    </section>

    <section id="chargeSection" style="display:none;">
      <h2>Charge Details</h2>
      <input type="number" id="amount" placeholder="2500" min="1" step="1" required>
      <input type="text" id="description" placeholder="Description" required>
      <button id="submit">Charge Now</button>
      <button id="chargeLater">Charge Later</button>
    </section>
  </div>

  <script>
  /* === Customers loader hard-fix === */
  (function () {
    const $ = s => document.querySelector(s);

    function withTimeout(promise, ms, label = 'request') {
      let t;
      return Promise.race([
        promise,
        new Promise((_, rej) => (t = setTimeout(() => rej(new Error(`${label} timed out after ${ms}ms`)), ms)))
      ]).finally(() => clearTimeout(t));
    }

    async function fetchJsonNoStore(url, label) {
      const res = await withTimeout(fetch(url, { cache: 'no-store' }), 10000, label || url);
      const text = await res.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch {
        throw new Error(`${label || url} returned non-JSON: ${text.slice(0, 200)}`);
      }
      if (!res.ok) {
        const msg = (data && (data.error || data.message)) || `${res.status} ${res.statusText}`;
        throw new Error(`${label || url} failed: ${msg}`);
      }
      return data;
    }

    function normalizeCustomers(payload) {
      if (Array.isArray(payload)) return payload;
      if (payload && Array.isArray(payload.customers)) return payload.customers;
      if (payload && Array.isArray(payload.data)) return payload.data;
      return [];
    }

    function showCustomerError(msg) {
      const sel = $('#custSel');
      if (sel) sel.innerHTML = `<option disabled selected>Failed to load customers — ${msg}</option>`;
      const help = $('#selHelp');
      if (help) {
        help.innerHTML = `${msg} <button id="retryLoad" class="link-btn">Retry</button>`;
        $('#retryLoad').onclick = () => {
          help.textContent = 'Retrying…';
          window.loadCustomersAndFill?.();
        };
      }
    }

    window.loadCustomersAndFill = async function loadCustomersAndFill() {
      try {
        let payload;
        try {
          payload = await fetchJsonNoStore('/.netlify/functions/list-customers', 'list-customers');
        } catch (e1) {
          console.warn('[fallback] list-customers failed:', e1);
          payload = await fetchJsonNoStore('/.netlify/functions/customers-list', 'customers-list');
        }

        const customers = normalizeCustomers(payload);
        if (!customers.length) return showCustomerError('no customers found');

        const sel = $('#custSel');
        sel.innerHTML = '<option disabled selected>Select a client…</option>';
        customers.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c.id;
          opt.textContent = c.name || c.email || c.id;
          sel.appendChild(opt);
        });

        sel.onchange = e => {
          window.selectedCustomer = { id: e.target.value };
          document.getElementById('chargeSection').style.display = 'block';
          window.refreshPaymentPickers?.();
        };
      } catch (err) {
        console.error(err);
        showCustomerError(err.message);
      }
    };

    window.addEventListener('load', window.loadCustomersAndFill);
  })();

  /* === Payment Methods & ACH normalization === */
  (function () {
    const $ = s => document.querySelector(s);

    function normalizeAch(pm) {
      const bank = pm.us_bank_account || pm.bank || {};
      const raw = bank.status || bank.verification_status || null;
      const verified = raw === 'verified' || raw === 'instant_verified' || raw === 'succeeded';
      return { bank_name: bank.bank_name || 'Bank Account', last4: bank.last4 || '••••', verified };
    }

    window.refreshPaymentPickers = async function refreshPaymentPickers() {
      const wrap = $('#pmPicker');
      wrap.innerHTML = '<div class="muted">Loading payment methods...</div>';

      const cid = window.selectedCustomer?.id;
      if (!cid) {
        wrap.innerHTML = '<div class="muted">Select a client first.</div>';
        return;
      }

      const data = await fetch(`/.netlify/functions/list-payment-methods?customerId=${cid}`, { cache: 'no-store' }).then(r => r.json());
      const pms = data.paymentMethods || [];
      wrap.innerHTML = '';

      pms.forEach(pm => {
        const row = document.createElement('label');
        if (pm.type === 'us_bank_account') {
          const ach = normalizeAch(pm);
          row.innerHTML = `<input type="radio" name="pmPick" value="${pm.id}" ${!ach.verified ? 'disabled' : ''}/> ${ach.bank_name} •••• ${ach.last4} <small>${ach.verified ? 'Verified' : 'Not verified'}</small>`;
        } else {
          const card = pm.card || {};
          row.innerHTML = `<input type="radio" name="pmPick" value="${pm.id}"/> ${card.brand || 'Card'} •••• ${card.last4 || '0000'}`;
        }
        wrap.appendChild(row);
      });
    };
  })();

  /* === Charge Later === */
  (function () {
    const $ = s => document.querySelector(s);

    async function postData(url = '', data = {}) {
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      return res.json();
    }

    $('#chargeLater').addEventListener('click', async () => {
      const cid = window.selectedCustomer?.id;
      const pmid = document.querySelector('input[name="pmPick"]:checked')?.value;
      const amount = $('#amount').value;
      const description = $('#description').value;

      if (!cid || !pmid || !amount || !description) {
        alert('Missing fields');
        return;
      }

      const payload = {
        customerId: cid,
        paymentMethodId: pmid,
        amount: parseInt(amount, 10),
        description,
        statementDescriptor: 'ROOFENGINE OUTBOUND',
        date: new Date().toISOString().split('T')[0],
        time: new Date().toLocaleTimeString(),
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
      };

      console.log('Submitting Charge Later payload:', payload);
      const res = await postData('/.netlify/functions/outbound-client-charge-later', payload);
      console.log('Charge Later response:', res);
      alert(res.error ? res.error : 'Charge scheduled successfully');
    });
  })();
  </script>
</body>
</html>
